<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GOL: GOL Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo_64.png"/></td>
  <td id="projectalign">
   <div id="projectname">GOL
   </div>
   <div id="projectbrief">Game Of Life</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_g_o_l-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">GOL Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Moteur de simulation d'un automate cellulaire à 2 dimensions.  
 <a href="class_g_o_l.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_g_o_l_8h_source.html">GOL.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_o_l_1_1_author.html">Author</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Le type représentant les informations permettant d'identifier les auteurs de l'implémentation.  <a href="struct_g_o_l_1_1_author.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_o_l_1_1_color.html">Color</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Le type représentant une couleur.  <a href="struct_g_o_l_1_1_color.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_o_l_1_1_implementation_information.html">ImplementationInformation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Le type représentant les informations documentant l'implémentation.  <a href="struct_g_o_l_1_1_implementation_information.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_g_o_l_1_1_statistics.html">Statistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Le type représentant des données statistiques de la simulation.  <a href="struct_g_o_l_1_1_statistics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab40533a07f138789826faa52a6f644aa" id="r_ab40533a07f138789826faa52a6f644aa"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aa">State</a> : uint8_t { <a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aaaf58e6a506c76fc2c90a7d29cbc631c2f">dead</a> = 0
, <a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aaa7bd3d5f5b3cdb13aed632121206e729c">alive</a> = 1
 }</td></tr>
<tr class="memdesc:ab40533a07f138789826faa52a6f644aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Le type représentant l'état d'une cellule.  <a href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aa">More...</a><br /></td></tr>
<tr class="separator:ab40533a07f138789826faa52a6f644aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f80ecf85fb6970fb8aa19fdc72488c5" id="r_a8f80ecf85fb6970fb8aa19fdc72488c5"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_o_l.html#a8f80ecf85fb6970fb8aa19fdc72488c5">BorderManagement</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="class_g_o_l.html#a8f80ecf85fb6970fb8aa19fdc72488c5a1959daeb0273318781b4aa35f118676d">immutableAsIs</a> = 0
, <a class="el" href="class_g_o_l.html#a8f80ecf85fb6970fb8aa19fdc72488c5a303cf94b70e6f7dffb1e094570e1759f">foreverDead</a>
, <a class="el" href="class_g_o_l.html#a8f80ecf85fb6970fb8aa19fdc72488c5a6845ed92fb9b5afe34b3cb58a03143bb">foreverAlive</a>
, <a class="el" href="class_g_o_l.html#a8f80ecf85fb6970fb8aa19fdc72488c5ad26fea1f666f50ab33e246806ed4829b">warping</a>
, <br />
&#160;&#160;<a class="el" href="class_g_o_l.html#a8f80ecf85fb6970fb8aa19fdc72488c5afbe322a89bc0ba531c3f0050e3935f28">mirror</a>
<br />
 }</td></tr>
<tr class="memdesc:a8f80ecf85fb6970fb8aa19fdc72488c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Le type représentant la stratégie de gestion de bord.  <a href="class_g_o_l.html#a8f80ecf85fb6970fb8aa19fdc72488c5">More...</a><br /></td></tr>
<tr class="separator:a8f80ecf85fb6970fb8aa19fdc72488c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f73ea2245fe25688a8f2b8ad444498" id="r_a63f73ea2245fe25688a8f2b8ad444498"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_o_l.html#a63f73ea2245fe25688a8f2b8ad444498">IterationType</a> = uint32_t</td></tr>
<tr class="memdesc:a63f73ea2245fe25688a8f2b8ad444498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Le type représentant le nombre d'itération de la simulation.  <br /></td></tr>
<tr class="separator:a63f73ea2245fe25688a8f2b8ad444498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfa284246f15ca8b2fe3b72d39398c4" id="r_a8dfa284246f15ca8b2fe3b72d39398c4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_o_l.html#a8dfa284246f15ca8b2fe3b72d39398c4">ColorChannelType</a> = uint8_t</td></tr>
<tr class="memdesc:a8dfa284246f15ca8b2fe3b72d39398c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Le type représentant un canal de couleur.  <br /></td></tr>
<tr class="separator:a8dfa284246f15ca8b2fe3b72d39398c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2d1ce427c1902aa396385b78aa5faacd" id="r_a2d1ce427c1902aa396385b78aa5faacd"><td class="memItemLeft" align="right" valign="top"><a id="a2d1ce427c1902aa396385b78aa5faacd" name="a2d1ce427c1902aa396385b78aa5faacd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GOL</b> ()=default</td></tr>
<tr class="memdesc:a2d1ce427c1902aa396385b78aa5faacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur par défaut. <br /></td></tr>
<tr class="separator:a2d1ce427c1902aa396385b78aa5faacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93d6b83a53990fd27e6fc152b549e41" id="r_ab93d6b83a53990fd27e6fc152b549e41"><td class="memItemLeft" align="right" valign="top"><a id="ab93d6b83a53990fd27e6fc152b549e41" name="ab93d6b83a53990fd27e6fc152b549e41"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GOL</b> (size_t <a class="el" href="class_g_o_l.html#a0f9371c1d919e8731a00f72c9e7e5338">width</a>, size_t <a class="el" href="class_g_o_l.html#a639614c14d19f9f200208c1b1d13e610">height</a>, <a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aa">State</a> defaultState=<a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aaaf58e6a506c76fc2c90a7d29cbc631c2f">State::dead</a>)</td></tr>
<tr class="memdesc:ab93d6b83a53990fd27e6fc152b549e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur d'initialisation personnalisé. <br /></td></tr>
<tr class="separator:ab93d6b83a53990fd27e6fc152b549e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f920566f6053820e4a39c1c0ffe14a" id="r_a71f920566f6053820e4a39c1c0ffe14a"><td class="memItemLeft" align="right" valign="top"><a id="a71f920566f6053820e4a39c1c0ffe14a" name="a71f920566f6053820e4a39c1c0ffe14a"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~GOL</b> ()=default</td></tr>
<tr class="memdesc:a71f920566f6053820e4a39c1c0ffe14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructeur. <br /></td></tr>
<tr class="separator:a71f920566f6053820e4a39c1c0ffe14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9371c1d919e8731a00f72c9e7e5338" id="r_a0f9371c1d919e8731a00f72c9e7e5338"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_o_l.html#a0f9371c1d919e8731a00f72c9e7e5338">width</a> () const =0</td></tr>
<tr class="memdesc:a0f9371c1d919e8731a00f72c9e7e5338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseur retournant la largeur de la grille de simualtion.  <br /></td></tr>
<tr class="separator:a0f9371c1d919e8731a00f72c9e7e5338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639614c14d19f9f200208c1b1d13e610" id="r_a639614c14d19f9f200208c1b1d13e610"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_o_l.html#a639614c14d19f9f200208c1b1d13e610">height</a> () const =0</td></tr>
<tr class="memdesc:a639614c14d19f9f200208c1b1d13e610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseur retournant la hauteur de la grille de simualtion.  <br /></td></tr>
<tr class="separator:a639614c14d19f9f200208c1b1d13e610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e362245fec1c4411835b6ca5eb1a62b" id="r_a7e362245fec1c4411835b6ca5eb1a62b"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_o_l.html#a7e362245fec1c4411835b6ca5eb1a62b">size</a> () const =0</td></tr>
<tr class="memdesc:a7e362245fec1c4411835b6ca5eb1a62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseur retournant le nombre total de cellules de la grille de simualtion.  <br /></td></tr>
<tr class="separator:a7e362245fec1c4411835b6ca5eb1a62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f034838a60adb25e1ef26a3eb309aa" id="r_a33f034838a60adb25e1ef26a3eb309aa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aa">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_o_l.html#a33f034838a60adb25e1ef26a3eb309aa">state</a> (int x, int y) const =0</td></tr>
<tr class="memdesc:a33f034838a60adb25e1ef26a3eb309aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseur retournant l'état d'une cellule.  <br /></td></tr>
<tr class="separator:a33f034838a60adb25e1ef26a3eb309aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7c43805a2ffbc09d0c76a20953d40d" id="r_a3e7c43805a2ffbc09d0c76a20953d40d"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_o_l.html#a3e7c43805a2ffbc09d0c76a20953d40d">rule</a> () const =0</td></tr>
<tr class="memdesc:a3e7c43805a2ffbc09d0c76a20953d40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseur retournant la chaîne de caractères correspondant à la règle courante.  <br /></td></tr>
<tr class="separator:a3e7c43805a2ffbc09d0c76a20953d40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7eb9dfd0d705bcd3093374a65071e9" id="r_acb7eb9dfd0d705bcd3093374a65071e9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_g_o_l.html#a8f80ecf85fb6970fb8aa19fdc72488c5">BorderManagement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_o_l.html#acb7eb9dfd0d705bcd3093374a65071e9">borderManagement</a> () const =0</td></tr>
<tr class="memdesc:acb7eb9dfd0d705bcd3093374a65071e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseur retournant la stratégie courante de gestion des bords.  <br /></td></tr>
<tr class="separator:acb7eb9dfd0d705bcd3093374a65071e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034f2b25cdb174e8db8b45c19c6ff227" id="r_a034f2b25cdb174e8db8b45c19c6ff227"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_g_o_l_1_1_color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_o_l.html#a034f2b25cdb174e8db8b45c19c6ff227">color</a> (<a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aa">State</a> <a class="el" href="class_g_o_l.html#a33f034838a60adb25e1ef26a3eb309aa">state</a>) const =0</td></tr>
<tr class="memdesc:a034f2b25cdb174e8db8b45c19c6ff227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseur retournant la couleur d'un état.  <br /></td></tr>
<tr class="separator:a034f2b25cdb174e8db8b45c19c6ff227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1855e686984d4533fc2442f6f3b89f2" id="r_ac1855e686984d4533fc2442f6f3b89f2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_g_o_l_1_1_statistics.html">Statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_o_l.html#ac1855e686984d4533fc2442f6f3b89f2">statistics</a> () const =0</td></tr>
<tr class="memdesc:ac1855e686984d4533fc2442f6f3b89f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseurs retournant des informations générales sur la simulation en cours.  <br /></td></tr>
<tr class="separator:ac1855e686984d4533fc2442f6f3b89f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee16ffdbff2b3fe49bdfb961cf85a7af" id="r_aee16ffdbff2b3fe49bdfb961cf85a7af"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_g_o_l_1_1_implementation_information.html">ImplementationInformation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_o_l.html#aee16ffdbff2b3fe49bdfb961cf85a7af">information</a> () const =0</td></tr>
<tr class="memdesc:aee16ffdbff2b3fe49bdfb961cf85a7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesseurs retournant les informations sur la réalisation de l'implémentation.  <br /></td></tr>
<tr class="separator:aee16ffdbff2b3fe49bdfb961cf85a7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb68a308596df6cc833915fe25b8b31" id="r_aeeb68a308596df6cc833915fe25b8b31"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_o_l.html#aeeb68a308596df6cc833915fe25b8b31">resize</a> (size_t <a class="el" href="class_g_o_l.html#a0f9371c1d919e8731a00f72c9e7e5338">width</a>, size_t <a class="el" href="class_g_o_l.html#a639614c14d19f9f200208c1b1d13e610">height</a>, <a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aa">State</a> defaultState=<a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aaaf58e6a506c76fc2c90a7d29cbc631c2f">State::dead</a>)=0</td></tr>
<tr class="memdesc:aeeb68a308596df6cc833915fe25b8b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutateur modifiant la taille de la grille de simulation.  <br /></td></tr>
<tr class="separator:aeeb68a308596df6cc833915fe25b8b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed680727507df7541f28b1b3be099364" id="r_aed680727507df7541f28b1b3be099364"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_o_l.html#aed680727507df7541f28b1b3be099364">setRule</a> (std::string const &amp;<a class="el" href="class_g_o_l.html#a3e7c43805a2ffbc09d0c76a20953d40d">rule</a>)=0</td></tr>
<tr class="memdesc:aed680727507df7541f28b1b3be099364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutateur modifiant la règle de la simulation.  <br /></td></tr>
<tr class="separator:aed680727507df7541f28b1b3be099364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e05013566674a629cb5046be9c4fd53" id="r_a4e05013566674a629cb5046be9c4fd53"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_o_l.html#a4e05013566674a629cb5046be9c4fd53">setBorderManagement</a> (<a class="el" href="class_g_o_l.html#a8f80ecf85fb6970fb8aa19fdc72488c5">BorderManagement</a> <a class="el" href="class_g_o_l.html#acb7eb9dfd0d705bcd3093374a65071e9">borderManagement</a>)=0</td></tr>
<tr class="memdesc:a4e05013566674a629cb5046be9c4fd53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutateur modifiant la stratégie de gestion de bord.  <br /></td></tr>
<tr class="separator:a4e05013566674a629cb5046be9c4fd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae421e565fbf6ba31db44d71eba7227b3" id="r_ae421e565fbf6ba31db44d71eba7227b3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_o_l.html#ae421e565fbf6ba31db44d71eba7227b3">setState</a> (int x, int y, <a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aa">State</a> <a class="el" href="class_g_o_l.html#a33f034838a60adb25e1ef26a3eb309aa">state</a>)=0</td></tr>
<tr class="memdesc:ae421e565fbf6ba31db44d71eba7227b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutateur modifiant l'état d'une cellule de la grille.  <br /></td></tr>
<tr class="separator:ae421e565fbf6ba31db44d71eba7227b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd8fe0cc3c4ea6e0234f165e0ae0909" id="r_a7fd8fe0cc3c4ea6e0234f165e0ae0909"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_o_l.html#a7fd8fe0cc3c4ea6e0234f165e0ae0909">fill</a> (<a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aa">State</a> <a class="el" href="class_g_o_l.html#a33f034838a60adb25e1ef26a3eb309aa">state</a>=<a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aaaf58e6a506c76fc2c90a7d29cbc631c2f">State::dead</a>)=0</td></tr>
<tr class="memdesc:a7fd8fe0cc3c4ea6e0234f165e0ae0909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutateur remplissant de façon uniforme toutes les cellules de la grille.  <br /></td></tr>
<tr class="separator:a7fd8fe0cc3c4ea6e0234f165e0ae0909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15588c452004483dd12ed01f63ebb7a" id="r_ae15588c452004483dd12ed01f63ebb7a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_o_l.html#ae15588c452004483dd12ed01f63ebb7a">fillAlternately</a> (<a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aa">State</a> firstCell=<a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aaaf58e6a506c76fc2c90a7d29cbc631c2f">State::dead</a>)=0</td></tr>
<tr class="memdesc:ae15588c452004483dd12ed01f63ebb7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutateur remplissant de façon alternée toutes les cellules de la grille.  <br /></td></tr>
<tr class="separator:ae15588c452004483dd12ed01f63ebb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a750d5e715c35bcddc1c5702a1c1bd" id="r_a48a750d5e715c35bcddc1c5702a1c1bd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_o_l.html#a48a750d5e715c35bcddc1c5702a1c1bd">randomize</a> (double percentAlive=0.5)=0</td></tr>
<tr class="memdesc:a48a750d5e715c35bcddc1c5702a1c1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutateur remplissant de façon aléatoire toutes les cellules de la grille.  <br /></td></tr>
<tr class="separator:a48a750d5e715c35bcddc1c5702a1c1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09cbd32232ddf08296e4709f2a7b7b7" id="r_af09cbd32232ddf08296e4709f2a7b7b7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_o_l.html#af09cbd32232ddf08296e4709f2a7b7b7">setFromPattern</a> (std::string const &amp;pattern, int centerX, int centerY)=0</td></tr>
<tr class="memdesc:af09cbd32232ddf08296e4709f2a7b7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutateur remplissant la grille par le patron passé en argument.  <br /></td></tr>
<tr class="separator:af09cbd32232ddf08296e4709f2a7b7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f2161a93817f8eda610319a9593f82" id="r_ad7f2161a93817f8eda610319a9593f82"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_o_l.html#ad7f2161a93817f8eda610319a9593f82">setFromPattern</a> (std::string const &amp;pattern)=0</td></tr>
<tr class="memdesc:ad7f2161a93817f8eda610319a9593f82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutateur remplissant la grille par le patron passé en argument.  <br /></td></tr>
<tr class="separator:ad7f2161a93817f8eda610319a9593f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98dbb31bb7d7ab708f69f276a0849361" id="r_a98dbb31bb7d7ab708f69f276a0849361"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_o_l.html#a98dbb31bb7d7ab708f69f276a0849361">setSolidColor</a> (<a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aa">State</a> <a class="el" href="class_g_o_l.html#a33f034838a60adb25e1ef26a3eb309aa">state</a>, <a class="el" href="struct_g_o_l_1_1_color.html">Color</a> const &amp;<a class="el" href="class_g_o_l.html#a034f2b25cdb174e8db8b45c19c6ff227">color</a>)=0</td></tr>
<tr class="memdesc:a98dbb31bb7d7ab708f69f276a0849361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutateur modifiant la couleur d'un état.  <br /></td></tr>
<tr class="separator:a98dbb31bb7d7ab708f69f276a0849361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163e43658479f589311944e45f9d2f7d" id="r_a163e43658479f589311944e45f9d2f7d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_o_l.html#a163e43658479f589311944e45f9d2f7d">processOneStep</a> ()=0</td></tr>
<tr class="memdesc:a163e43658479f589311944e45f9d2f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction effectuant une itération de la simulation.  <br /></td></tr>
<tr class="separator:a163e43658479f589311944e45f9d2f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023f299fa22d29d595ce8f5b559556eb" id="r_a023f299fa22d29d595ce8f5b559556eb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_g_o_l.html#a023f299fa22d29d595ce8f5b559556eb">updateImage</a> (uint32_t *buffer, size_t buffer_size) const =0</td></tr>
<tr class="memdesc:a023f299fa22d29d595ce8f5b559556eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fonction dessinant l'état de la simulation sur une image passée en paramètre.  <br /></td></tr>
<tr class="separator:a023f299fa22d29d595ce8f5b559556eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Moteur de simulation d'un automate cellulaire à 2 dimensions. </p>
<p>La classe <a class="el" href="class_g_o_l.html" title="Moteur de simulation d&#39;un automate cellulaire à 2 dimensions.">GOL</a> représente une interface standardisée visant l'implémentation complète et suffisante d'un engin de simulation d'un automate cellulaire à 2 dimensions.</p>
<p>Cette classe abstraite ne fait rien et ne possède aucun attribut. Elle ne constitue qu'un modèle standardisé pouvant être facilement utilisé pour réaliser une simulation.</p>
<p>La classe possède :</p><ul>
<li>la définition des types utilitaires</li>
<li>la définition et l'implémentation de :<ul>
<li>le constructeur par défaut</li>
<li>un constructeur personnalisé (cette définition est absolument inutile et en temps normal elle serait absente de ce fichier, sa présence n'est qu'à titre d'exemples pédagogiques)</li>
<li>le destructeur virtuel</li>
</ul>
</li>
<li>la définition de plusieurs fonctions abstraites (virtuelles pures).</li>
</ul>
<p>L'approche utilisée est donc un parfait exemple d'un développement modulaire s'appuyant sur le polymorphisme. Néanmoins, pour rester critique, cette classe présente un défaut de conception du fait qu'elle réalise beaucoup trop de tâches à elle seule. Un découpage mieux structuré serait préférable considérant un projet d'envergure. La forme actuelle de cette conception vise à mettre l'emphase du développement sur les objetifs du projet sans être dérangé par d'autres aspects : conception et implémentation de structures de données et d'algorithmes.</p>
<p>Puisque cette classe est abstraite, elle est destiné à être héritée afin que vous implémentiez <b>entièrement</b> un engin de type automate cellulaire répondant strictement à l'interface présentée.</p>
<p>Éléments importants :</p><ul>
<li>Vous devez implémenter entièrement le moteur de simulation.</li>
<li>La grille est 2d de dimensions finies.</li>
<li><b>En tout temps la classe doit être dans un état consistant.</b> Peu importe l'ordre d'appel des fonctions. De plus, il doit être possible d'appeler n'importe quelle fonction et que son effet soit immédiat (dans la mesure de la logique).</li>
<li>À l'initialisation de votre engin, la configuration par défaut est :<ul>
<li>grille de 100 x 100</li>
<li>toutes les cellules sont mortes</li>
<li>règle de Conway : <code>B3/S23</code></li>
<li>stratégie de gestion de bord : <a class="el" href="class_g_o_l.html#a8f80ecf85fb6970fb8aa19fdc72488c5a303cf94b70e6f7dffb1e094570e1759f" title="Les cellules du contour ne sont jamais modifiées. Elles sont toujours mortes.">BorderManagement::foreverDead</a></li>
<li>itération courante : 0</li>
<li>les couleurs sont noires pour les cellules mortes et blanches pour les cellules vivantes</li>
</ul>
</li>
<li>Vous devez avoir une représentation interne indépendante de la représentation à l'écran.</li>
<li>Vous devez être en mesure de gérer n'importe quelle règle. Les règles sont définies par une chaîne de caractère suivant ce format : <code>B###.../S###...</code></li>
<li>Vous devez être en mesure de gérer les effets de bord selon 5 stratégies différentes : <br  />
<ol type="1">
<li>immuable tel quel</li>
<li>mort pour toujours</li>
<li>vivant pour toujours</li>
<li>téléportation</li>
<li>miroir</li>
</ol>
</li>
<li>Vous devez être en mesure d'initialiser la grille de plusieurs façons :<ol type="1">
<li>remplir avec une valeur uniforme (mort ou vivant)</li>
<li>remplir en forme de damier (en pouvant préciser la valeur de la première cellule : mort ou vivant)</li>
<li>remplir aléatoirement avec un pourcentage de probabilité, pour chaque cellule, d'être vivant</li>
<li>mettre un patron centré sur la grille</li>
<li>manuellement, cellule par cellule, avec la fonction setState(...)</li>
</ol>
</li>
<li>La fonction <a class="el" href="class_g_o_l.html#a163e43658479f589311944e45f9d2f7d" title="Fonction effectuant une itération de la simulation.">GOL::processOneStep</a> doit faire un pas de simulation.</li>
<li>Vous devez utiliser le type <a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aa" title="Le type représentant l&#39;état d&#39;une cellule.">GOL::State</a> pour représenter chaque cellule de la simulation utilise, .</li>
<li>Vous devez être capable de produire une représentation visuelle de la représentation interne. La fonction <a class="el" href="class_g_o_l.html#a023f299fa22d29d595ce8f5b559556eb" title="Fonction dessinant l&#39;état de la simulation sur une image passée en paramètre.">GOL::updateImage</a> vous passe le <em>buffer</em> où se trouve l'image de sortie. C'est dans cette zone mémoire que vous devez dessiner la représentation visuelle de la simulation.</li>
<li>Plusieurs mutateurs réinitialisent le compteur d'itération à 0.<ul>
<li>Voici ceux qui réinitialisent le compteur d'itération :<ul>
<li><a class="el" href="class_g_o_l.html#aeeb68a308596df6cc833915fe25b8b31" title="Mutateur modifiant la taille de la grille de simulation.">GOL::resize</a></li>
<li><a class="el" href="class_g_o_l.html#a7fd8fe0cc3c4ea6e0234f165e0ae0909" title="Mutateur remplissant de façon uniforme toutes les cellules de la grille.">GOL::fill</a></li>
<li><a class="el" href="class_g_o_l.html#ae15588c452004483dd12ed01f63ebb7a" title="Mutateur remplissant de façon alternée toutes les cellules de la grille.">GOL::fillAlternately</a></li>
<li><a class="el" href="class_g_o_l.html#af09cbd32232ddf08296e4709f2a7b7b7" title="Mutateur remplissant la grille par le patron passé en argument.">GOL::setFromPattern</a></li>
<li><a class="el" href="class_g_o_l.html#a48a750d5e715c35bcddc1c5702a1c1bd" title="Mutateur remplissant de façon aléatoire toutes les cellules de la grille.">GOL::randomize</a></li>
<li><a class="el" href="class_g_o_l.html#aed680727507df7541f28b1b3be099364" title="Mutateur modifiant la règle de la simulation.">GOL::setRule</a></li>
<li><a class="el" href="class_g_o_l.html#a4e05013566674a629cb5046be9c4fd53" title="Mutateur modifiant la stratégie de gestion de bord.">GOL::setBorderManagement</a></li>
</ul>
</li>
<li>Ce dernier laisse inchangé le compteur d'itération :<ul>
<li><a class="el" href="class_g_o_l.html#ae421e565fbf6ba31db44d71eba7227b3" title="Mutateur modifiant l&#39;état d&#39;une cellule de la grille.">GOL::setState</a></li>
</ul>
</li>
</ul>
</li>
<li>À tout moment, il doit être possible de questionner la simulation afin d'obtenir les informations contenues dans la structure <a class="el" href="struct_g_o_l_1_1_statistics.html" title="Le type représentant des données statistiques de la simulation.">GOL::Statistics</a>. On remarque que toutes les informations sont stockées dans un std::optional. Ainsi, si vous n'avez pas la réponse, vous pouvez simplement laissé la valeur indéterminée.</li>
<li>Vous devez implémenter une autre classe qui s'occupe de gérer une structure de données 2d. Cette classe, nommée Grid, est une encapsulation dirigée d'une matrice 2d. Voir plus bas dans cette page pour les détails. </li>
</ul>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8dfa284246f15ca8b2fe3b72d39398c4" name="a8dfa284246f15ca8b2fe3b72d39398c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dfa284246f15ca8b2fe3b72d39398c4">&#9670;&#160;</a></span>ColorChannelType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_g_o_l.html#a8dfa284246f15ca8b2fe3b72d39398c4">GOL::ColorChannelType</a> =  uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Le type représentant un canal de couleur. </p>
<p>Le type choisi est un entier non signé de 8 bits. </p>

</div>
</div>
<a id="a63f73ea2245fe25688a8f2b8ad444498" name="a63f73ea2245fe25688a8f2b8ad444498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f73ea2245fe25688a8f2b8ad444498">&#9670;&#160;</a></span>IterationType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_g_o_l.html#a63f73ea2245fe25688a8f2b8ad444498">GOL::IterationType</a> =  uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Le type représentant le nombre d'itération de la simulation. </p>
<p>Le type choisi est un entier non signé de 32 bits. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a8f80ecf85fb6970fb8aa19fdc72488c5" name="a8f80ecf85fb6970fb8aa19fdc72488c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f80ecf85fb6970fb8aa19fdc72488c5">&#9670;&#160;</a></span>BorderManagement</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="class_g_o_l.html#a8f80ecf85fb6970fb8aa19fdc72488c5">GOL::BorderManagement</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Le type représentant la stratégie de gestion de bord. </p>
<p>L'algorithme de simulation doit gérer les effets de bord. C'est-à-dire que les calculs de voisinage doivent être adaptés pour les cellules situées sur les bords de la grille.</p>
<p>5 modes de gestion sont possibles. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8f80ecf85fb6970fb8aa19fdc72488c5a1959daeb0273318781b4aa35f118676d" name="a8f80ecf85fb6970fb8aa19fdc72488c5a1959daeb0273318781b4aa35f118676d"></a>immutableAsIs&#160;</td><td class="fielddoc"><p>Les cellules du contour ne sont jamais modifiées. Elles sont laissées dans leur état courant. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8f80ecf85fb6970fb8aa19fdc72488c5a303cf94b70e6f7dffb1e094570e1759f" name="a8f80ecf85fb6970fb8aa19fdc72488c5a303cf94b70e6f7dffb1e094570e1759f"></a>foreverDead&#160;</td><td class="fielddoc"><p>Les cellules du contour ne sont jamais modifiées. Elles sont toujours mortes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8f80ecf85fb6970fb8aa19fdc72488c5a6845ed92fb9b5afe34b3cb58a03143bb" name="a8f80ecf85fb6970fb8aa19fdc72488c5a6845ed92fb9b5afe34b3cb58a03143bb"></a>foreverAlive&#160;</td><td class="fielddoc"><p>Les cellules du contour ne sont jamais modifiées. Elles sont toujours vivantes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8f80ecf85fb6970fb8aa19fdc72488c5ad26fea1f666f50ab33e246806ed4829b" name="a8f80ecf85fb6970fb8aa19fdc72488c5ad26fea1f666f50ab33e246806ed4829b"></a>warping&#160;</td><td class="fielddoc"><p>Les cellules du contour sont évaluées. On utilise les cellules du côté opposé de la grille pour les cellules extérieures. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8f80ecf85fb6970fb8aa19fdc72488c5afbe322a89bc0ba531c3f0050e3935f28" name="a8f80ecf85fb6970fb8aa19fdc72488c5afbe322a89bc0ba531c3f0050e3935f28"></a>mirror&#160;</td><td class="fielddoc"><p>Les cellules du contour sont évaluées. On utilise les cellules du côté opposé de la cellule pour les cellules extérieures. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab40533a07f138789826faa52a6f644aa" name="ab40533a07f138789826faa52a6f644aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab40533a07f138789826faa52a6f644aa">&#9670;&#160;</a></span>State</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aa">GOL::State</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Le type représentant l'état d'une cellule. </p>
<p>L'état d'une cellule peut être mort ou vivant. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab40533a07f138789826faa52a6f644aaaf58e6a506c76fc2c90a7d29cbc631c2f" name="ab40533a07f138789826faa52a6f644aaaf58e6a506c76fc2c90a7d29cbc631c2f"></a>dead&#160;</td><td class="fielddoc"><p>L'état mort. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab40533a07f138789826faa52a6f644aaa7bd3d5f5b3cdb13aed632121206e729c" name="ab40533a07f138789826faa52a6f644aaa7bd3d5f5b3cdb13aed632121206e729c"></a>alive&#160;</td><td class="fielddoc"><p>L'état vivant. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acb7eb9dfd0d705bcd3093374a65071e9" name="acb7eb9dfd0d705bcd3093374a65071e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7eb9dfd0d705bcd3093374a65071e9">&#9670;&#160;</a></span>borderManagement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_g_o_l.html#a8f80ecf85fb6970fb8aa19fdc72488c5">BorderManagement</a> GOL::borderManagement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesseur retournant la stratégie courante de gestion des bords. </p>
<dl class="section return"><dt>Returns</dt><dd>La stratégie courante de gestion des bords. </dd></dl>

</div>
</div>
<a id="a034f2b25cdb174e8db8b45c19c6ff227" name="a034f2b25cdb174e8db8b45c19c6ff227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034f2b25cdb174e8db8b45c19c6ff227">&#9670;&#160;</a></span>color()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_g_o_l_1_1_color.html">Color</a> GOL::color </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aa">State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesseur retournant la couleur d'un état. </p>
<p>Cette fonction retourne la couleur associée à l'état passé en argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>L'état dont on veut connaître la couleur. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>La couleur associée à l'état. </dd></dl>

</div>
</div>
<a id="a7fd8fe0cc3c4ea6e0234f165e0ae0909" name="a7fd8fe0cc3c4ea6e0234f165e0ae0909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd8fe0cc3c4ea6e0234f165e0ae0909">&#9670;&#160;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GOL::fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aa">State</a>&#160;</td>
          <td class="paramname"><em>state</em> = <code><a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aaaf58e6a506c76fc2c90a7d29cbc631c2f">State::dead</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutateur remplissant de façon uniforme toutes les cellules de la grille. </p>
<p>Cette fonction remplit toutes les cellules de la grille avec l'état passé en argument.</p>
<p>L'itération courante est remise à 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>L'état d'initialisation des cellules. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae15588c452004483dd12ed01f63ebb7a" name="ae15588c452004483dd12ed01f63ebb7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15588c452004483dd12ed01f63ebb7a">&#9670;&#160;</a></span>fillAlternately()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GOL::fillAlternately </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aa">State</a>&#160;</td>
          <td class="paramname"><em>firstCell</em> = <code><a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aaaf58e6a506c76fc2c90a7d29cbc631c2f">State::dead</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutateur remplissant de façon alternée toutes les cellules de la grille. </p>
<p>Cette fonction remplit toutes les cellules de la grille avec un motif en damier. La première cellule, en haut à gauche, est de l'état passée en argument.</p>
<p>L'itération courante est remise à 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstCell</td><td>L'état de la première cellule. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a639614c14d19f9f200208c1b1d13e610" name="a639614c14d19f9f200208c1b1d13e610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a639614c14d19f9f200208c1b1d13e610">&#9670;&#160;</a></span>height()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t GOL::height </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesseur retournant la hauteur de la grille de simualtion. </p>
<dl class="section return"><dt>Returns</dt><dd>La hauteur de la grille. </dd></dl>

</div>
</div>
<a id="aee16ffdbff2b3fe49bdfb961cf85a7af" name="aee16ffdbff2b3fe49bdfb961cf85a7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee16ffdbff2b3fe49bdfb961cf85a7af">&#9670;&#160;</a></span>information()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_g_o_l_1_1_implementation_information.html">ImplementationInformation</a> GOL::information </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesseurs retournant les informations sur la réalisation de l'implémentation. </p>
<p>Retourne plusieurs informations sur la réalisation de l'implémentation. Chaque valeur est optionnelle et peut être indéterminée.</p>
<p>En quelque sorte, c'est l'approche utilisée pour produire un mini rapport utilitaire.</p>
<p>Voir la documentation liée à la structure <a class="el" href="struct_g_o_l_1_1_implementation_information.html" title="Le type représentant les informations documentant l&#39;implémentation.">ImplementationInformation</a> pour plus de détails.</p>
<p>Pour les réponses 'answers', l'objectif est d'utiliser clairement le vocabulaire technique approprié tout en étant très concis et très précis.</p>
<dl class="section return"><dt>Returns</dt><dd>Une structure contenant les informations sur la réalisation </dd></dl>

</div>
</div>
<a id="a163e43658479f589311944e45f9d2f7d" name="a163e43658479f589311944e45f9d2f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163e43658479f589311944e45f9d2f7d">&#9670;&#160;</a></span>processOneStep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GOL::processOneStep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fonction effectuant une itération de la simulation. </p>
<p>Cette fonction constitue la partie centrale de la simulation. Elle est responsable de faire évoluer la grille d'une itération.</p>
<p>Cette fonction doit appliquer la logique de l'automate cellulaire en tenant compte pour chaque cellule :</p><ul>
<li>de la grille</li>
<li>de l'état de chacune des cellules voisines</li>
<li>de la règle de la simulation</li>
<li>de la stratégie de gestion de bord</li>
</ul>
<p>Après l'appel de cette fonction, la grille est mise à jour avec le nouvel état de chaque cellule suivant l'état précédent. Les statistiques doivent tenir compte de cette évolution. </p>

</div>
</div>
<a id="a48a750d5e715c35bcddc1c5702a1c1bd" name="a48a750d5e715c35bcddc1c5702a1c1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a750d5e715c35bcddc1c5702a1c1bd">&#9670;&#160;</a></span>randomize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GOL::randomize </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>percentAlive</em> = <code>0.5</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutateur remplissant de façon aléatoire toutes les cellules de la grille. </p>
<p>Cette fonction remplit toutes les cellules de la grille avec un motif aléatoire. Le pourcentage de probabilité d'une cellule d'être vivante est passé en argument.</p>
<p>L'itération courante est remise à 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">percentAlive</td><td>Le pourcentage de probabilité d'une cellule d'être vivante. La valeur doit être comprise entre 0.0 et 1.0 inclusivement. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeeb68a308596df6cc833915fe25b8b31" name="aeeb68a308596df6cc833915fe25b8b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb68a308596df6cc833915fe25b8b31">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GOL::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aa">State</a>&#160;</td>
          <td class="paramname"><em>defaultState</em> = <code><a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aaaf58e6a506c76fc2c90a7d29cbc631c2f">State::dead</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutateur modifiant la taille de la grille de simulation. </p>
<p>Cette fonction réinitialise la taille et le contenu de la grille. La taille est spécifié peut être 0 x 0. Le contenu de la grille est entièrement mis à l'état passé en argument.</p>
<p>Cette fonction s'assure que si l'une des dimensions est 0, alors les deux sont mises à 0.</p>
<p>L'ancient motif de la grille est perdu. L'itération courante est remise à 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>La nouvelle largeur de la grille. </td></tr>
    <tr><td class="paramname">height</td><td>La nouvelle hauteur de la grille. </td></tr>
    <tr><td class="paramname">defaultState</td><td>L'état d'initialisation des cellules. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e7c43805a2ffbc09d0c76a20953d40d" name="a3e7c43805a2ffbc09d0c76a20953d40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7c43805a2ffbc09d0c76a20953d40d">&#9670;&#160;</a></span>rule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string GOL::rule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesseur retournant la chaîne de caractères correspondant à la règle courante. </p>
<p>La chaîne de caractères est de la forme "B###/S###".</p>
<dl class="section return"><dt>Returns</dt><dd>La chaîne de caractères correspondant à la règle courante selon le format <code>B###.../S###...</code>. </dd></dl>

</div>
</div>
<a id="a4e05013566674a629cb5046be9c4fd53" name="a4e05013566674a629cb5046be9c4fd53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e05013566674a629cb5046be9c4fd53">&#9670;&#160;</a></span>setBorderManagement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GOL::setBorderManagement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_o_l.html#a8f80ecf85fb6970fb8aa19fdc72488c5">BorderManagement</a>&#160;</td>
          <td class="paramname"><em>borderManagement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutateur modifiant la stratégie de gestion de bord. </p>
<p>Cette fonction assigne la nouvelle stratégie pour que les prochaines évolutions l'utilisent.</p>
<p>L'ancienne stratégie est perdue. L'itération courante est remise à 0.</p>
<p>Vous devez être en mesure de gérer les effets de bord selon 5 stratégies différentes : <br  />
</p><ul>
<li><a class="el" href="class_g_o_l.html#a8f80ecf85fb6970fb8aa19fdc72488c5a1959daeb0273318781b4aa35f118676d" title="Les cellules du contour ne sont jamais modifiées. Elles sont laissées dans leur état courant.">BorderManagement::immutableAsIs</a> : immuable tel quel. Les cellules du contour ne sont jamais modifiées.</li>
<li><a class="el" href="class_g_o_l.html#a8f80ecf85fb6970fb8aa19fdc72488c5a303cf94b70e6f7dffb1e094570e1759f" title="Les cellules du contour ne sont jamais modifiées. Elles sont toujours mortes.">BorderManagement::foreverDead</a> : mort pour toujours. Les cellules du contour ne sont jamais modifiées, elles sont toujours mortes.</li>
<li><a class="el" href="class_g_o_l.html#a8f80ecf85fb6970fb8aa19fdc72488c5a6845ed92fb9b5afe34b3cb58a03143bb" title="Les cellules du contour ne sont jamais modifiées. Elles sont toujours vivantes.">BorderManagement::foreverAlive</a> : vivant pour toujours. Les cellules du contour ne sont jamais modifiées, elles sont toujours vivantes.</li>
<li><a class="el" href="class_g_o_l.html#a8f80ecf85fb6970fb8aa19fdc72488c5ad26fea1f666f50ab33e246806ed4829b" title="Les cellules du contour sont évaluées. On utilise les cellules du côté opposé de la grille pour les c...">BorderManagement::warping</a> : téléportation. Les cellules du contour sont évaluées. On utilise les cellules du côté opposé de la grille pour les cellules extérieures.</li>
<li><a class="el" href="class_g_o_l.html#a8f80ecf85fb6970fb8aa19fdc72488c5afbe322a89bc0ba531c3f0050e3935f28" title="Les cellules du contour sont évaluées. On utilise les cellules du côté opposé de la cellule pour les ...">BorderManagement::mirror</a> : miroir. Les cellules du contour sont évaluées. On utilise les cellules du côté opposé de la cellule pour les cellules extérieures.</li>
</ul>
<p>Pour les 2 exemples suivants, la cellule analysée <code>-*-</code> possède 3 voisins situés à l'extérieur de la grille 'x', 'y' et 'z'. Ces cellules sont substituées par les voisins opposés 'X', 'Y' et 'Z'.</p>
<p><a class="el" href="class_g_o_l.html#a8f80ecf85fb6970fb8aa19fdc72488c5ad26fea1f666f50ab33e246806ed4829b" title="Les cellules du contour sont évaluées. On utilise les cellules du côté opposé de la grille pour les c...">BorderManagement::warping</a> utilise les voisins opposés par rapport à la <b>grille</b>.</p>
<pre>
    +---+---+---+---+---+ 
  x |   |   |   |   | X |
    +---+---+---+---+---+
  y |-*-|   |   |   | Y |
    +---+---+---+---+---+
  z |   |   |   |   | Z |
</pre><p><a class="el" href="class_g_o_l.html#a8f80ecf85fb6970fb8aa19fdc72488c5afbe322a89bc0ba531c3f0050e3935f28" title="Les cellules du contour sont évaluées. On utilise les cellules du côté opposé de la cellule pour les ...">BorderManagement::mirror</a> utilise les voisins opposés par rapport à la <b>cellule</b>.</p>
<pre>
    +---+---+---+---+---+ 
  x |   | X |   |   |   |
    +---+---+---+---+---+
  y |-*-| Y |   |   |   |
    +---+---+---+---+---+
  z |   | Z |   |   |   |
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">borderManagement</td><td>La nouvelle stratégie de gestion de bord. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7f2161a93817f8eda610319a9593f82" name="ad7f2161a93817f8eda610319a9593f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f2161a93817f8eda610319a9593f82">&#9670;&#160;</a></span>setFromPattern() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GOL::setFromPattern </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutateur remplissant la grille par le patron passé en argument. </p>
<p>Cette fonction est une surcharge utilitaire de la fonction <a class="el" href="class_g_o_l.html#af09cbd32232ddf08296e4709f2a7b7b7" title="Mutateur remplissant la grille par le patron passé en argument.">setFromPattern(std::string const &amp; pattern, int centerX, int centerY)</a>. Cette version utilise le centre de la grille comme centre du patron.</p>
<p>L'itération courante est remise à 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>Le patron à appliquer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true si le patron est valide, false sinon. </dd></dl>

</div>
</div>
<a id="af09cbd32232ddf08296e4709f2a7b7b7" name="af09cbd32232ddf08296e4709f2a7b7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09cbd32232ddf08296e4709f2a7b7b7">&#9670;&#160;</a></span>setFromPattern() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GOL::setFromPattern </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>centerX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>centerY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutateur remplissant la grille par le patron passé en argument. </p>
<p>Cette fonction remplit la grille avec le patron donné. Le patron est centré sur la coordonnées (centerX, centerY).</p>
<p>Le patron respecte un format précis. Se référer à l'énoncé pour voir tous les détails.</p>
<p>Si le patron n'est pas valide, la grille n'est pas modifiée et on retourne false. Sinon, on retourne vrai.</p>
<p>L'itération courante est remise à 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>Le patron à appliquer. </td></tr>
    <tr><td class="paramname">centerX</td><td>La coordonnée en x de la grille où se trouve centré le patron. </td></tr>
    <tr><td class="paramname">centerY</td><td>La coordonnée en y de la grille où se trouve centré le patron. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true si le patron est valide, false sinon. </dd></dl>

</div>
</div>
<a id="aed680727507df7541f28b1b3be099364" name="aed680727507df7541f28b1b3be099364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed680727507df7541f28b1b3be099364">&#9670;&#160;</a></span>setRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool GOL::setRule </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>rule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutateur modifiant la règle de la simulation. </p>
<p>Cette fonction s'assure que la chaîne de caractères est valide et assigne la nouvelle règle pour que les prochaines évolutions l'utilisent.</p>
<p>Si la règle est valide, on assigne la novuelle règle, l'ancienne règle est perdue et l'itération courante est remise à 0. Si la règle est invalide, on ne fait rien.</p>
<p>La simulation doit être en mesure de supporté les règles valides.</p>
<p>Les règles sont définies par une chaîne de caractère suivant ce format: <code>B###.../S###...</code>, par exemple : <code>B3/S23</code>.</p><ul>
<li>La lettre <code>B</code> (minuscule ou majuscule) débute la section 'B'orn concernant les états morts qui naissent</li>
<li>Suit une série de <em>n</em> caractères pouvant contenir une instance de chacun de ces caractères : '0', '1', '2', '3', '4', '5', '6', '7', '8'. La valeur de <em>n</em> peut varier de 0 à 9. Cette séquence indique toutes les combinaisons du nombre de cellules voisines vivantes qui font naître une cellule morte.</li>
<li>Le caractère barre oblique <code>/</code> (<em>slash</em>) qui indique la transition vers la section suivante.</li>
<li>La lettre <code>S</code> (minuscule ou majuscule) débute la section 'S'urvive concernant les états vivants qui survivent (qui restent vivantes).</li>
<li>Suit une série de <em>n</em> caractères pouvant contenir une instance de chacun de ces caractères : '0', '1', '2', '3', '4', '5', '6', '7', '8'. La valeur de <em>n</em> peut varier de 0 à 9. Cette séquence indique toutes les combinaisons du nombre de cellules voisines vivantes qui font naître une cellule morte.</li>
</ul>
<p>Par exemple : <code>B02/S1357</code> indique que :</p><ul>
<li>si une cellule est morte :<ul>
<li>elle naît se elle possède 0 ou 2 voisins vivants</li>
</ul>
</li>
<li>si la cellule est vivante :<ul>
<li>elle survie si elle possède 1, 3, 5 ou 7 voisins vivants</li>
</ul>
</li>
</ul>
<p>La règle de Conway <code>B3/S23</code> est celle par défaut. </p>

</div>
</div>
<a id="a98dbb31bb7d7ab708f69f276a0849361" name="a98dbb31bb7d7ab708f69f276a0849361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98dbb31bb7d7ab708f69f276a0849361">&#9670;&#160;</a></span>setSolidColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GOL::setSolidColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aa">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_g_o_l_1_1_color.html">Color</a> const &amp;&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutateur modifiant la couleur d'un état. </p>
<p>Cette fonction modifie la couleur d'un état.</p>
<p>Formellement, cette fonction ne modifie rien en soit mais plutôt permet de stocker quelle couleur utiliser pour représenter un état lors de l'affichage de la grille sur une image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>L'état dont on veut modifier la couleur. </td></tr>
    <tr><td class="paramname">color</td><td>La nouvelle couleur de l'état. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae421e565fbf6ba31db44d71eba7227b3" name="ae421e565fbf6ba31db44d71eba7227b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae421e565fbf6ba31db44d71eba7227b3">&#9670;&#160;</a></span>setState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GOL::setState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aa">State</a>&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutateur modifiant l'état d'une cellule de la grille. </p>
<p>Cette fonction ne valide pas les entrées pour une raison de performance. L'origine est le coin supérieur gauche de la grille.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>La coordonnée en x de la cellule. </td></tr>
    <tr><td class="paramname">y</td><td>La coordonnée en y de la cellule. </td></tr>
    <tr><td class="paramname">state</td><td>Le nouvel état de la cellule. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e362245fec1c4411835b6ca5eb1a62b" name="a7e362245fec1c4411835b6ca5eb1a62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e362245fec1c4411835b6ca5eb1a62b">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t GOL::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesseur retournant le nombre total de cellules de la grille de simualtion. </p>
<dl class="section return"><dt>Returns</dt><dd>Le nombre total de cellules de la grille. </dd></dl>

</div>
</div>
<a id="a33f034838a60adb25e1ef26a3eb309aa" name="a33f034838a60adb25e1ef26a3eb309aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f034838a60adb25e1ef26a3eb309aa">&#9670;&#160;</a></span>state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_g_o_l.html#ab40533a07f138789826faa52a6f644aa">State</a> GOL::state </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesseur retournant l'état d'une cellule. </p>
<p>Cette fonction ne valide pas les entrées pour une raison de performance. L'origine est le coin supérieur gauche de la grille.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>La coordonnée en x de la cellule. </td></tr>
    <tr><td class="paramname">y</td><td>La coordonnée en y de la cellule. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>L'état de la cellule. </dd></dl>

</div>
</div>
<a id="ac1855e686984d4533fc2442f6f3b89f2" name="ac1855e686984d4533fc2442f6f3b89f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1855e686984d4533fc2442f6f3b89f2">&#9670;&#160;</a></span>statistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_g_o_l_1_1_statistics.html">Statistics</a> GOL::statistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesseurs retournant des informations générales sur la simulation en cours. </p>
<p>Retourne plusieurs informations sur la simulation. Chaque valeur est optionnelle et peut être indéterminée.</p>
<p>Voir la documentation liée à la structure <a class="el" href="struct_g_o_l_1_1_statistics.html" title="Le type représentant des données statistiques de la simulation.">Statistics</a> pour plus de détails.</p>
<p>Toutefois, les tendances sont définies ainsi :</p><ul>
<li>La tendance indique la variation entre le nombre de cellules mortes et vivantes en valeur absolue et relative.</li>
<li>Une tendance est à la hausse s'il y a plus de cellules naissantes que mourantes.</li>
<li>Un premier caractères indique si la tendance est à la hausse (+) ou à la baisse (-).</li>
<li>La tendance doit se faire sur un certain nombre d'itérations. Ce nombre est défini par l'implémentation mais doit être supérieur à 10 itérations. L'objectif est d'avoir une lecture relativement stable de la tendance afin qu'elle soit agréable à lire dans l'interface usager.</li>
<li>Optionnellement, vous pouvez ajouter un second caractère indiquant la stabilité de la tendance. Voici la légende :<ul>
<li>'-' : stable</li>
<li>'~' : légèrement instable</li>
<li>'w' : instable</li>
<li>'W' : très instable</li>
</ul>
</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Une structure contenant les informations sur la simulation. </dd></dl>

</div>
</div>
<a id="a023f299fa22d29d595ce8f5b559556eb" name="a023f299fa22d29d595ce8f5b559556eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a023f299fa22d29d595ce8f5b559556eb">&#9670;&#160;</a></span>updateImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void GOL::updateImage </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fonction dessinant l'état de la simulation sur une image passée en paramètre. </p>
<p>Cette fonction dessine l'état courant de chaque cellule sur l'image donnée. Chaque pixel de l'image correspond à une cellule de la grille de simulation.</p>
<p>La couleur de chaque pixel est déterminée par la couleur associée à l'état de la cellule.</p>
<p>L'organisation en mémoire est ce qu'on appel 'Packed Pixel' suivant l'ordre ARGB. Ainsi, toutes les données d'un pixel est contiguë en mémoire. Les 4 canaux de couleurs sont stockés dans un entier non signé de 32 bits. Chaque canal est codé sur 8 bits. Le canal alpha est le plus significatif et le canal bleu est le moins significatif.</p>
<p>La variable buffer pointe vers un tableau de pixels de taille buffer_size. La taille de l'image est donc buffer_size / sizeof(uint32_t).</p>
<pre>
[           32 bits            ]
[8 bits][8 bits][8 bits][8 bits]
[alpha ][red   ][green ][blue  ]
[alpha ][rouge ][vert  ][bleu  ]
</pre><p>Vous pouvez considérer que l'image a été créée avec le format de Qt QImage::Format_ARGB32.</p>
<p>Il est attendu que vous fassiez une validation minimum des intrants.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Le tableau de pixels de l'image. </td></tr>
    <tr><td class="paramname">buffer_size</td><td>La taille du tableau de pixels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f9371c1d919e8731a00f72c9e7e5338" name="a0f9371c1d919e8731a00f72c9e7e5338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f9371c1d919e8731a00f72c9e7e5338">&#9670;&#160;</a></span>width()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t GOL::width </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accesseur retournant la largeur de la grille de simualtion. </p>
<dl class="section return"><dt>Returns</dt><dd>La largeur de la grille. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
